1) Требования
— Установить: pip install catboost pandas numpy scikit-learn для обучения, сохранения/загрузки модели и предсказаний.  
— Python‑скрипты используют argparse для CLI, что позволяет задавать параметры обучения из консоли.  

2) Файлы проекта
— ts_model.py: логика признаков, конфиг TSConfig, обучение CatBoost, сохранение/загрузка артефактов model.cbm/meta.json.  
— train.py: CLI для обучения из CSV и записи артефактов в указанный каталог с помощью CatBoost save_model.  
— streaming_service.py: сервис со StreamingForecaster и ForecastService, метод process_message(msg, K) для онлайн‑прогноза.  

3) Подготовка данных
— convert_data.py читает структуру папок с физиологическими данными (hypoxia/regular -> group_id -> bpm/uterus -> CSV файлы), объединяет их в единый DataFrame с колонками: timestamp, group_id, sequence_id, bpm, uterus, target.  
— timestamp уже в секундах от эпохи после merge_physiological_data, дополнительного преобразования не требуется.  
— Значения group_id гарантируют раздельность пациентов в train/valid через GroupShuffleSplit при обучении.  

4) Обучение (CLI)
— Команда: python train.py --input_csv /path/to/data_directory --out_dir artifacts --task_type CPU — обучит модель и валидирует по группам (group_id).  
— Параметр --input_csv ожидает путь к папке с данными (содержащей hypoxia/regular подпапки), а не к CSV файлу.  
— Дополнительные параметры: --iterations, --learning_rate, --depth, --val_size, --verbose — переопределяют значения из TSConfig, не изменяя код.  

5) Где сохраняется модель
— После успешного обучения в каталоге --out_dir появятся: model.cbm (CatBoost) и meta.json (конфиг и список feature_cols), сохранённые через save_model и JSON‑дамп.  
— Эти артефакты используются инференс‑сервисом через load_model и чтение meta.json для консистентного порядка признаков на predict.  

6) Стриминг: инициализация сервиса
— В приложении создать сервис: from streaming_service import ForecastService; svc = ForecastService("artifacts") — «artifacts» это путь к папке с model.cbm/meta.json.  
— Сервис готов принимать сообщения и вести состояние по каждому (group_id, sequence_id) до накопления min max_lag точек, необходимых для старта прогноза.  

7) Формат входящего сообщения [web:59]
— msg = "timestamp,bpm,uterus,group_id,sequence_id" — строка из 5 значений, разделённых запятыми.  
— timestamp может быть числом секунд от эпохи или ISO‑строкой, приводится к секундам внутри сервиса.  
— Для ISO‑строк время переводится через pandas.to_datetime(...).value/1e9, что обеспечивает единый формат времени для расчёта лагов.  

8) Вызов онлайн‑прогноза [web:82]
— На каждое сообщение: out = svc.process_message(msg, K) — K это горизонт прогноза в шагах, метод обновит буферы и вернёт прогноз при готовности.  
— Ответ в строковом формате: "ready:bool,forecast:data,needed:int"; когда ready=true, forecast содержит прогнозы, разделённые ';': timestamp,group_id,sequence_id,bpm,uterus,h.  

9) Когда начинается прогноз [web:82]
— Для каждого ряда сервис накапливает минимум max_lag исторических точек, после чего переходит к регулярным обновлениям update_one+forecast при приходе новых сообщений.  
— До прогрева поле "needed" сообщает, сколько точек ещё требуется накопить для старта прогноза по данному (group_id, sequence_id).  

10) Принцип прогноза (рекурсивный multi‑step) [web:82]
— Прогноз на K шагов строится итеративно: модель предсказывает t+1, добавляет прогноз в лаги и предсказывает t+2 и т.д., пока не будет получено K точек.  
— Такой подход является стандартным для табличных ML‑моделей с лаговыми признаками и поддерживается единым CatBoostRegressor.predict.  

11) Смена версии модели [web:22]
— Переобучить модель новой командой train.py на свежем CSV и сохранить в новый каталог, например artifacts_v2, чтобы зафиксировать новую версию.  
— Запустить сервис с новым путём: ForecastService("artifacts_v2") или переключить путь при деплое, обеспечив атомарную смену модели.  

12) Пример использования
# svc = ForecastService(model_dir="artifacts")
# msg = "1609459200,85.5,12.3,patient_1,session_1"
# K = 5  # прогноз на 5 шагов вперёд
# out = svc.process_message(msg, K)
# # Парсинг ответа: "ready:true,forecast:ts1,gid,sid,bpm1,ut1,1;ts2,gid,sid,bpm2,ut2,2;...,needed:0"
# parts = out.split(',')
# if parts[0] == "ready:true":
#     forecast_data = parts[1].split(':')[1]  # извлекаем forecast данные
#     predictions = forecast_data.split(';')  # разделяем по прогнозам
#     for pred_str in predictions:
#         if pred_str:
#             pred_values = pred_str.split(',')
#             step = pred_values[5]
#             bpm_pred = pred_values[3]
#             uterus_pred = pred_values[4]
#             print(f"Step {step}: bpm={bpm_pred}, uterus={uterus_pred}")
# else:
#     # Парсим needed из ответа
#     needed_part = [p for p in out.split(',') if p.startswith('needed:')][0]
#     needed = needed_part.split(':')[1]
#     print(f"Need {needed} more points before forecasting can start")  