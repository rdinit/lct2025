1) Требования
— Установить: pip install catboost pandas numpy scikit-learn для обучения, сохранения/загрузки модели и предсказаний.  
— Python‑скрипты используют argparse для CLI, что позволяет задавать параметры обучения из консоли.  

2) Файлы проекта
— ts_model.py: логика признаков, конфиг TSConfig, обучение CatBoost, сохранение/загрузка артефактов model.cbm/meta.json.  
— train.py: CLI для обучения из CSV и записи артефактов в указанный каталог с помощью CatBoost save_model.  
— streaming_service.py: сервис со StreamingForecaster и ForecastService, метод process_message(msg, K) для онлайн‑прогноза.  

3) Подготовка данных
— CSV с колонками: timestamp, group_id, sequence_id, bpm, uterus; timestamp может быть строкой или числом и конвертируется в секунды от эпохи внутри пайплайна.  
— Значения group_id гарантируют раздельность пациентов в train/valid через GroupShuffleSplit при обучении.  

4) Обучение (CLI)
— Команда: python train.py --input_csv data.csv --out_dir artifacts --task_type CPU — обучит модель и валидирует по группам (group_id).  
— Дополнительные параметры: --iterations, --learning_rate, --depth, --val_size, --verbose — переопределяют значения из TSConfig, не изменяя код.  

5) Где сохраняется модель
— После успешного обучения в каталоге --out_dir появятся: model.cbm (CatBoost) и meta.json (конфиг и список feature_cols), сохранённые через save_model и JSON‑дамп.  
— Эти артефакты используются инференс‑сервисом через load_model и чтение meta.json для консистентного порядка признаков на predict.  

6) Стриминг: инициализация сервиса
— В приложении создать сервис: from streaming_service import ForecastService; svc = ForecastService("artifacts") — «artifacts» это путь к папке с model.cbm/meta.json.  
— Сервис готов принимать сообщения и вести состояние по каждому (group_id, sequence_id) до накопления min max_lag точек, необходимых для старта прогноза.  

7) Формат входящего сообщения [web:59]
— msg = {"timestamp": <число секунд от эпохи или ISO‑строка>, "bpm": float, "uterus": float, "group_id": <str|int>, "sequence_id": <str|int>} — timestamp приводится к секундам внутри сервиса.  
— Для ISO‑строк время переводится через pandas.to_datetime(...).value/1e9, что обеспечивает единый формат времени для расчёта лагов.  

8) Вызов онлайн‑прогноза [web:82]
— На каждое сообщение: out = svc.process_message(msg, K) — K это горизонт прогноза в шагах, метод обновит буферы и вернёт прогноз при готовности.  
— Ответ: {"ready": bool, "forecast": List[Dict], "needed": int}; когда ready=True, forecast — это список из K будущих точек с полями timestamp, group_id, sequence_id, bpm, uterus и h.  

9) Когда начинается прогноз [web:82]
— Для каждого ряда сервис накапливает минимум max_lag исторических точек, после чего переходит к регулярным обновлениям update_one+forecast при приходе новых сообщений.  
— До прогрева поле "needed" сообщает, сколько точек ещё требуется накопить для старта прогноза по данному (group_id, sequence_id).  

10) Принцип прогноза (рекурсивный multi‑step) [web:82]
— Прогноз на K шагов строится итеративно: модель предсказывает t+1, добавляет прогноз в лаги и предсказывает t+2 и т.д., пока не будет получено K точек.  
— Такой подход является стандартным для табличных ML‑моделей с лаговыми признаками и поддерживается единым CatBoostRegressor.predict.  

11) Смена версии модели [web:22]
— Переобучить модель новой командой train.py на свежем CSV и сохранить в новый каталог, например artifacts_v2, чтобы зафиксировать новую версию.  
— Запустить сервис с новым путём: ForecastService("artifacts_v2") или переключить путь при деплое, обеспечив атомарную смену модели.  