# Лидеры Цифровой Трансформации 2025
 
*14-Bit MISIS*

Team Members:

1. **Калинин Алексей** - ML, Captain
2. **Чистов Егор** - Backend
3. **Зеленский Данил** - Frontend
4. **Быков Вадим** - Analyst, Design
5. **Рыжичкин Кирилл** - ML

Презентация: [тык](https://google.com)

Демонстрация сервиса на Orange Pi: [тык]()

Веб-сервис: [тык](https://14bit.itatmisis.ru/)

## Кейс "Веб-сервис предиктивной аналитики физиологических данных с интеграцией в медицинское оборудование"

> Cоздать веб-платформу, которая станет «цифровым ассистентом» для врачей в родильных отделениях. Приложение будет запускаться на фетальном мониторе для отслеживания состояния и прогнозирования течения беременности пациентки, находящейся под наблюдением.

## Предложенное решение

Мы предоставляем сервис для врачей, имеющий следующий функционал:
- forecast:
  - catboost: авторегрессионно предсказывает K следующих шагов (например, 10-60 минут), позволяет делать быстрые и точные прогнозы и успевать их отрисовывать на экране, rmse=3
  - прочее: также пробовали prophet, arima, etna и прочие библиотеки, catboost был наиболее оптимальным с точки зрения скорости и качества
- детекция аномалий:
  - mad based: максимально прост и быстр и качественно находит выбросы, его легко использовать на cpu не нагружая систему
  - isolation forest: показывал неплохие результаты, но долго инферился, поэтому отказались от него
  - unet1d autoencoder: для работы на npu мы обучили unet1d восстанавливать исходный ряд из его аугментаций, добившись наилучшей точности, однако не успели встроить на наш npu, однако сам функционал готов - ![ноутбук моделирования unet1d](ml/unet_reconstructor.ipynb)
- классификация:
  - catboost: для классификации ряда на regular/hypoxia использовали catboost
  - cnn1d: исходно обучали cnn1d, однако она дала только 0.55 f1 macro, в то время как catboost был быстрее и достигал 0.75 f1 macro на небольшом наборе фичей при честной валидации
- определение диагнозов:
  - rule-based: для определения тахикардии, брадикардии, децелерации и вариабельности использовали rule-based подход, т.к не было разметки, а также эти диагнозы действительно точно определяются набором правил

Детекцию аномалий, классификацию гипоксии, определение диагнозов мы делаем не только на истинных рядах, но и на наших предсказаниях, которые делает forecast модуль.

## Дополнительно:
- для денойзинга рядов использовали фильтр Савицкого-Голея для бустингов и фильтр Калмана для нейросетей
- аугментации: jitter, scaling, time warping, magnitude warping, window slicing, window warping
- все ml сервисы (forecast, classify, anomaly, diagnosis) работают быстро и точно в стриминг режиме
- есть функции обучения моделей, чтобы дообучать их на новых актуальных данных (или делать персонализированные модели под определенные группы пациентов)

## Фичи для бустинга:
- скользяцие статистики (разные окна, разные статистики)
- svd энтропия
- petrosian fd
- количество пиков

Данный набор обеспечил наилучший trade-off между качеством и скоростью, мы пробовали множество фичей из scipy, antropy и прочих библиотек.

## Валидация

Для валидации везде использовали StratifiedGroupKfold, где группа - пациент, тагрет - гипоксия. Таким образом у нас в трейне и тесте всегда разные пациенты, что защищает нас от утечки данных и не завышает метрики.

## Backend

 - Написан на Go
 - Через websockets обрабатывает данные с датчиков и раздает их всем клиентам
 - Синхронизирует данные с датчиков и передает их ML для анализа

## Frontend

- Сделан на React с NextJS
- Подключается к Websocket бэкенда и показывает данные предиктов
- Графики строятся на canvas для облегчения dom-а и оптимизации при работе с OrangePI
